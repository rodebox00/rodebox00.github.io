---
layout: post
title: Fileless Malware
---

En la actualidad existen diversos tipos de malware, tales como rootkits, gusanos, ransomwares, etc. Un modelo menos conocido pero no por ello menos peligroso es el fileless malware. Como particularidad, a diferencia de los demás, el código del mismo no se encuentra en el disco del sistema sino que se carga directamente en memoria. 

En este artículo se explica en que consiste este tipo de malware y cuales son sus características principales. De forma más técnica, se simula un escenario real donde se crea un fileless malware que se emplea para infectar una máquina Windows 10. La carga en memoria del código y la persistencia en el sistema vendrá apoyada por un programa legítimo modificado. Adicionalmente se detallarán un conjunto de contramedidas para prevenir y detectar este tipo de código malicioso. 

# ¿Qué es el fileless malware?

El fileless malware es un tipo concreto de malware cuyo código no se encuentra en un fichero dentro del equipo, sino en memoria RAM. Esto conlleva que el malware sea muy volátil, es decir, al apagar el equipo este se elimina. Es por ello que normalmente se apoya en un código externo que lo cargar en memoria desde una fuente remota. Este código de carga suele estar embebido en un programa o fichero manipulado. Para este último caso, en sistemas Windows una práctica frecuente es la de insertar código en archivos de office usando macros. Una vez en ejecución, el malware intenta lograr persistencia, es decir, que el código de carga se ejecute cada vez que se inicia el sistema. Debido a esto, se suelen crear tareas periódicas o servicios que usen este código y descarguen la pieza de malware en cada inicio del sistema. En el caso particular de Windows, también se crean claves de registro o se realiza el [secuestro en el orden de búsqueda de DLLs](https://learn.microsoft.com/en-gb/windows/win32/dlls/dynamic-link-library-search-order?redirectedfrom=MSDN). Cabe destacar que en algunos escenarios como la presencia del backdoor [DoublePulsar](https://www.morphisec.com/hubfs/wp-content/uploads/2017/11/Fileless-Malware_Attack-Trend-Exposed.pdf), se puede prescindir del código externo e inyectar el malware directamente en memoria mediante paquetes de red.

Por el contrario, el sistema víctima debe poder acceder a la fuente remota que proporciona el código correspondiente al malware. Es por ello que ante un sistema sin conexión con determinada red, el ataque no tendría éxito. De igual manera se obtendría el mismo resultado si se hiciera uso de un firewall que no permitiera la conexión al servidor remoto.

Una característica del fileless malware es que al no estar contenido en ningún archivo y ejecutarse en memoria, no es detectado por la mayoría de antivirus como [código malicioso](https://ieeexplore.ieee.org/document/8768769). De esta forma evade técnicas de detección como las basadas en firma o heurística. La no detección en memoria por parte de los antivirus se debe a que el análisis de comportamiento en memoria es muy costo en términos de recursos del sistema. Además, en una situación de post-ataque, la previa ejecución en memoria dificulta la acción de encontrar evidencias forenses.

Generalmente, el fileless malware utiliza herramientas legítimas del sistema con fines maliciosos, esta técnica es conocida como *living off the land*. En sistemas Windows, es común utilizar herramientas como  *powershell* o *Windows Management Instrumentation (WMI)*. Por el contrario, en sistemas GNU/Linux se suele hacer uso de la llamada al sistema [*ptrace()*](http://archive.hack.lu/2019/Fileless-Malware-Infection-and-Linux-Process-Injection-in-Linux-OS.pdf) que bloquea un proceso. Así mismo, también se emplea la llamada al sistema [*memfd\_create()*](https://magisterquis.github.io/2018/03/31/in-memory-only-elf-execution.html) que permite crear un archivo anónimo almacenado en memoria. El uso de estas herramientas añade aún más dificultad en la detección.

### Simulación de un escenario real

Para simular un posible escenario real, se ha desplegado una máquina virtual atacante y otra víctima
conectadas a través de una red virtual. La máquina atacante contiene una versión de Kali Linux, la
dirección IP 192.168.2.129 y alberga un servidor HTTP en el puerto 80 en el que proporciona un archivo
malicioso que contiene la funcionalidad del fileless malware. A su vez, se encuentra en escucha con *Netcat* por el puerto 443. Por el contrario, la máquina
víctima posee la dirección 192.168.2.128 y una versión de Windows 10 con *Microsoft Defender* en fun-
cionamiento.

Para la ejecución y propagación del fileless malware, se modifica un programa legítimo insertando
código adicional ofuscado mediante la herramienta *Shellter*. Esta herramienta es capaz de modifi-
car programas de Windows de 32-bits. En este caso el programa a modificar será *Stellarium*. La
finalidad del código insertado que se ejecutará cuando se inicie el programa, será la de descargar del
servidor de la máquina atacante una serie de comandos. Estos comandos conformaran el fileless malware
y se ejecutarán a través de powershell. Una vez que se descargan, se almacenarán en memoria sin escri-
bir en disco y provocarán la creación de un nuevo proceso de powershell ajeno a la ejecución del programa.

El malware creará (si no existe ya) una clave de registro que ejecutará un comando de descarga del servidor cada vez que se inicie el sistema, logrando así la persistencia dentro de la máquina. Adicionalmente y como objetivo final, entablará una reverse shell hacia la máquina atacante. A continuación se explican con más detalle los pasos seguidos en el desarrollo, propagación y ejecución del fileless malware.

#### Desarrollo de un fileless malware

Como se mencionaba anteriormente, para la inserción de código en un programa empleamos la herramienta Shellter. Una vez lanzada indicamos cual es el fichero a modificar, en este caso stellarium.exe.

{:refdef: style="text-align: center;"}
![My Image]({{ site.baseimg }}/images/FilelessMalware/Seleccion de binario con shellter.png)
{: refdef}

Tras seleccionar el programa añadimos el payload que se va a ejecutar, el cual se muestra a continuación.

{:refdef: style="text-align: center;"}
![My Image]({{ site.baseimg }}/images/FilelessMalware/Comando insertado.png)
{: refdef}

Con este payload lanzamos *powershell* y establecemos que no muestre ninguna ventana mediante la opción ***-W h***. Con la opción ***-c*** le indicamos el comando que debe ejecutar. Este comando se sustituirá por los comandos que se encuentran contenidos en el fichero *WinSecurityUpdate* del servidor atacante. Con el nombre del fichero a descargar buscamos evitar que el usuario piense que es malicioso.

A fin de minimizar la detección tanto por los antivirus como por la ingeniería inversa, ofuscamos el comando a ejecutar. Para ello, empleamos la herramienta [*Invoke-Obfuscation*](https://github.com/danielbohannon/Invoke-Obfuscation) que nos permite ofuscar comandos de powershell. Una vez que obtenemos el resultado, lo juntamos con la parte no ofuscada y lo indicamos en *Shellter*.

{:refdef: style="text-align: center;"}
![My Image]({{ site.baseimg }}/images/FilelessMalware/Seleccion de payload con shellter.png)
{: refdef}

Para comprobar la reducción en la detección por parte de los antivirus, subimos tanto el programa modificado como el legítimo a la plataforma de [*VirusTotal*](https://www.virustotal.com/gui/home/upload). El resultado del análisis se visualiza en las siguientes imágenes respectivamente. Según se observa, ambos son detectados como malware por 2 antivirus por lo que se ha disminuido con éxito el riesgo de detección.

{:refdef: style="text-align: center;"}
![My Image]({{ site.baseimg }}/images/FilelessMalware/Detección de antivirus.png)
{: refdef}

{:refdef: style="text-align: center;"}
![My Image]({{ site.baseimg }}/images/FilelessMalware/Detección de antivirus legitimo.png)
{: refdef}

En relación con el fichero *WinSecurityUpdate* almacenado en el servidor atacante, el contenido del mismo se muestra a continuación.

{:refdef: style="text-align: center;"}
![My Image]({{ site.baseimg }}/images/FilelessMalware/WinSecurityUpdate.png)
{: refdef}

Si dividimos en dos partes la secuencia de comandos, vemos que la primera se encarga de crear, si no existe ya, una nueva clave de registro denominada *WindowsSecurityUpdate*. El contenido de la misma es similar al payload embebido en el programa manipulado. De esta forma logramos persistencia, incluso aunque la clave sea borrada. Esta se crea en la ruta *HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run* con el fin de que se ejecute cada vez que se inicia el sistema.

{:refdef: style="text-align: center;"}
![My Image]({{ site.baseimg }}/images/FilelessMalware/Primera parte fichero.png)
{: refdef}

La segunda parte de la secuencia, se encarga de entablar una reverse shell hacia la máquina atacante. El objetivo de usar el puerto 443 como destino nos puede ayudar en el hipotético caso de que se emplease un firewall en la máquina víctima que no permitiera el tráfico hacia puertos desconocidos o que no corresponden a un servidor web.

{:refdef: style="text-align: center;"}
![My Image]({{ site.baseimg }}/images/FilelessMalware/Segunda parte fichero.png)
{: refdef}

Al igual que con parte del payload inyectado mediante *Shellter*, ofuscamos con *Invoke-Obfuscation* el comando que contendrá la clave *WindowsSecurityUpdate*. Una vez que lo tenemos, lo juntamos con el resto de comandos contenidos en *WinSecurityUpdate*.

{:refdef: style="text-align: center;"}
![My Image]({{ site.baseimg }}/images/FilelessMalware/Parte del fichero WinSecurityUpdate ofuscado.png)
{: refdef}

Una vez tenemos todos los comandos juntos, mediante \textit{Invoke-Obfuscation} obtenemos la ofuscación de los mismo quedando el contenido de \textit{WinSecurityUpdate} ilegible. Este corresponde a nuestro fileless malware.


### Propagación

En este caso, la propagación del malware conlleva la propagación del programa modificado. En consecuencia, podría realizarse de varias maneras.

  - Ingeniería social. Una posibilidad sería la de engañar a una persona mediante phising proporcionándole el programa y haciéndole creer que es legítimo. 
  - Manipulación del sitio web oficial. Si se realizase un ataque logrando el acceso al repositorio oficial del programa, la versión legítima se podría cambiar por la modificada.
  - Introducción directa en el sistema. Si se tuviera acceso a la máquina víctima, el programa podría ser instalado o intercambiado por el oficial. Incluso, se podría prescindir del programa y crear una clave de registro similar a la de *WindowsSecurityUpdate*.

#### Ataque

Una vez que el programa se encuentra dentro del sistema, el procedimiento de ataque sería sencillo. Cuando la víctima ejecute el programa modificado o el sistema se inicie (y exista la clave *WindowsSecurityUpdate*), se descargarán y ejecutarán en memoria los comandos maliciosos de *powershell* dando lugar a un nuevo proceso. Como resultado, el atacante tendría acceso a la máquina.

{:refdef: style="text-align: center;"}
![My Image]({{ site.baseimg }}/images/FilelessMalware/Establecimiento de reverse shell.png)
{: refdef}

Adicionalmente, si no existiera la clave *WindowsSecurityUpdate* o hubiera sido eliminada, se crearía tal y como se muestra a continuación.

{:refdef: style="text-align: center;"}
![My Image]({{ site.baseimg }}/images/FilelessMalware/Registro.png)
{: refdef}

Cabe destacar que la ejecución de este fileless malware es independiente de la política de ejecución de scripts de *powershell* y resulta indetectable por *Microsoft Defender*. Por lo tanto, aunque la ejecución de scripts de *powershell* esté deshabilitada y el antivirus activado, el malware se ejecutará. De forma más gráfica, a continuación se puede ver un ejemplo de un diagrama temporal que refleja el transcurso del ataque.

{:refdef: style="text-align: center;"}
![My Image]({{ site.baseimg }}/images/FilelessMalware/Diagrama temporal.png)
{: refdef}

#### Contramedidas

Dado que el fileless malware es difícilmente detectable, se deben poner esfuerzos en una serie de contramedidas que dificulten su propagación o faciliten la detección. Algunas corresponden con las siguientes:

  - Emplear [herramientas](https://learn.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite) de monitoreo de procesos como las proporcionadas por Microsoft para Windows.
  - Hacer uso de algún software de análisis de comportamientos anómalos en memoria.
  - Mantener el antivirus actualizado.
  - Desactivar el uso de macros por defecto en Office.
  - Comprobar el hash de cada programa o fichero descargado con el publicado en el sitio oficial confirmando su integridad.
  - Descargar archivos de fuentes oficiales y fiables.
  - Análisis profundo de una imagen de memoria para un estudio forense.
  - Análisis de logs asociados con herramientas de las que suele hacer uso el fileless malware (powershell, VMI, etc).
  - Revisión de las tareas periódicas establecidas y de las ubicaciones enfocadas a la persistencia.
  - Hacer uso de un firewall que no permita la conexión a fuentes desconocidas.

En relación con el caso práctico, una posible detección hubiera sido el análisis de logs pertenecientes a *powershell*, ya que estos no han sido borrados por el malware. Si observamos la siguiente imagen vemos como muestra el comando ejecutado que descarga el malware. 

{:refdef: style="text-align: center;"}
![My Image]({{ site.baseimg }}/images/FilelessMalware/Log de Poweshell.png)
{: refdef}

#### Conclusión

Como hemos visto a lo largo de este documento el fileless malware posee unas características particulares que lo hacen indetectable ante los antivirus convencionales. Esto hace aumentar el riesgo de propagación y el impacto que pueden tener incluso en sistemas aparentemente protegidos. A través de la simulación de un escenario real, se ha podido apreciar de forma más práctica la creación de un malware de este tipo y su comportamiento.

Dentro de las posibles contramedidas expuestas se encuentran algunas que pueden lograr eliminar el malware o minimizar su impacto. Para el caso práctico se muestra la aplicación de una de ellas en la que se aprecia claramente el uso anómalo que se realiza con *powershell*. Como conclusión final, en este documento queda expuesto lo desprotegido que puede estar un usuario final a día de hoy frente a este tipo de amenazas.


